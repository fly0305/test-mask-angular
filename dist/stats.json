{"errors":[],"warnings":[],"version":"1.12.12","hash":"67156139199fb5ed7b9e","publicPath":"","assetsByChunkName":{"main":"stringPattern.min.js"},"assets":[{"name":"stringPattern.min.js","size":12023,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"stats.json","size":0,"chunks":[],"chunkNames":[]}],"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":33704,"names":["main"],"files":["stringPattern.min.js"],"hash":"1c2b6258d88aa76e44ac","parents":[],"modules":[{"id":0,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","name":"./src/index.js","index":0,"index2":9,"size":646,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _conformToPattern = require(\"./conformToPattern.js\");\n\nObject.defineProperty(exports, \"conformToPattern\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_conformToPattern).default;\n  }\n});\n\nvar _adjustCursorPosition = require(\"./adjustCursorPosition.js\");\n\nObject.defineProperty(exports, \"adjustCursorPosition\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_adjustCursorPosition).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }"},{"id":1,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/utilities.js","name":"./src/utilities.js","index":2,"index2":1,"size":2713,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","module":"./src/adjustCursorPosition.js","moduleName":"./src/adjustCursorPosition.js","type":"cjs require","userRequest":"./utilities.js","loc":"12:17-42"},{"moduleId":4,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","module":"./src/assignUserInputToPatternParts.js","moduleName":"./src/assignUserInputToPatternParts.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":6,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getPatternParts.js","module":"./src/getPatternParts.js","moduleName":"./src/getPatternParts.js","type":"cjs require","userRequest":"./utilities.js","loc":"10:17-42"},{"moduleId":7,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getUserInputParts.js","module":"./src/getUserInputParts.js","moduleName":"./src/getUserInputParts.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":8,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/processPart.js","module":"./src/processPart.js","moduleName":"./src/processPart.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertPatternToPlaceholder = convertPatternToPlaceholder;\nexports.removeCharactersStartingAtIndex = removeCharactersStartingAtIndex;\nexports.getOperationType = getOperationType;\nexports.getDelimiters = getDelimiters;\nexports.printPadding = printPadding;\nexports.constructConformedString = constructConformedString;\n\nvar _constants = require('./constants.js');\n\nfunction convertPatternToPlaceholder() {\n  var pattern = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return pattern.replace(/1/g, _constants.placeholderCharacter);\n}\n\nfunction removeCharactersStartingAtIndex() {\n  var string = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n  var numberOfCharacters = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n  return string.substring(0, index) + string.substring(index + numberOfCharacters);\n}\n\nfunction getOperationType() {\n  var currentValue = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var previousValue = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n  return currentValue.length === previousValue.length ? _constants.operationTypes.replacement : currentValue.length > previousValue.length ? _constants.operationTypes.addition : currentValue.length < previousValue.length ? _constants.operationTypes.deletion : null;\n}\n\nfunction getDelimiters() {\n  var pattern = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return pattern.split('').reduce(function (accumulator, character) {\n    if (_constants.maskingCharacters.indexOf(character) === -1 && accumulator.indexOf(character) === -1) {\n      accumulator.push(character);\n    }\n\n    return accumulator;\n  }, []);\n}\n\nfunction printPadding(paddingCharacter, length) {\n  return Array.from({ length: length }, function () {\n    return paddingCharacter;\n  }).join('');\n}\n\nfunction constructConformedString(patternPartsWithContent) {\n  return patternPartsWithContent.reduce(function (accumulator, editableAreaWithContent) {\n    var _editableAreaWithCont = editableAreaWithContent.content;\n    var content = _editableAreaWithCont === undefined ? '' : _editableAreaWithCont;\n    var length = editableAreaWithContent.length;\n    var delimiter = editableAreaWithContent.delimiter;\n\n    var contentAndLengthDelta = length - content.length;\n    var padding = printPadding(_constants.placeholderCharacter, contentAndLengthDelta);\n\n    accumulator += content + padding + (delimiter || '');\n\n    return accumulator;\n  }, '');\n}"},{"id":2,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/constants.js","name":"./src/constants.js","index":3,"index2":0,"size":341,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/utilities.js","module":"./src/utilities.js","moduleName":"./src/utilities.js","type":"cjs require","userRequest":"./constants.js","loc":"13:17-42"},{"moduleId":3,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","module":"./src/adjustCursorPosition.js","moduleName":"./src/adjustCursorPosition.js","type":"cjs require","userRequest":"./constants.js","loc":"14:17-42"},{"moduleId":6,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getPatternParts.js","module":"./src/getPatternParts.js","moduleName":"./src/getPatternParts.js","type":"cjs require","userRequest":"./constants.js","loc":"8:17-42"},{"moduleId":8,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/processPart.js","module":"./src/processPart.js","moduleName":"./src/processPart.js","type":"cjs require","userRequest":"./constants.js","loc":"10:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar operationTypes = exports.operationTypes = {\n  replacement: 'replacement',\n  addition: 'addition',\n  deletion: 'deletion'\n};\n\nvar maskingCharacters = exports.maskingCharacters = ['1', 'A', '#'];\n\nvar placeholderCharacter = exports.placeholderCharacter = '_';"},{"id":3,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","name":"./src/adjustCursorPosition.js","index":8,"index2":8,"size":4292,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./adjustCursorPosition.js","loc":"16:28-64"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = adjustCursorPosition;\n\nvar _diff = require('diff');\n\nvar _diff2 = _interopRequireDefault(_diff);\n\nvar _utilities = require('./utilities.js');\n\nvar _constants = require('./constants.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction adjustCursorPosition() {\n  var previousUserInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var newUserInput = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n  var currentCursorPosition = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n  var pattern = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];\n\n  // Nothing changed. Keep cursor at where it currently is.\n  if (previousUserInput === newUserInput) {\n    return currentCursorPosition;\n  }\n\n  var diffResults = _diff2.default.diffChars(previousUserInput, newUserInput);\n\n  var addedCount = 0;\n  var removedCount = 0;\n  var charactersBeforeChangeOccurred = '';\n  var indexOfWhereChangeOccurred = -1;\n  var newCharacterIsPlaceholderCharacter = null;\n\n  diffResults.forEach(function (result) {\n    charactersBeforeChangeOccurred += result.value;\n\n    if (result.added === true) {\n      addedCount += result.count;\n      newCharacterIsPlaceholderCharacter = result.value === _constants.placeholderCharacter;\n      indexOfWhereChangeOccurred = indexOfWhereChangeOccurred === -1 ? charactersBeforeChangeOccurred.length - 1 : indexOfWhereChangeOccurred;\n    }\n\n    if (result.removed === true) {\n      removedCount += result.count;\n      indexOfWhereChangeOccurred = indexOfWhereChangeOccurred === -1 ? charactersBeforeChangeOccurred.length - 1 : indexOfWhereChangeOccurred;\n    }\n  });\n\n  //console.log(diffResults);\n  //console.log(indexOfWhereChangeOccurred);\n  //console.log(newCharacterIsPlaceholderCharacter);\n\n  // The cursor position and the change are too far apart, which means some ambiguous change\n  // happened. I.e (333) ___-____ to (333) 3__-____\n  // In that case, just return the currentCursorPosition\n  if (indexOfWhereChangeOccurred - currentCursorPosition > 1) {\n    return currentCursorPosition;\n  }\n\n  // There are more than one change in the diffResults, which means we're dealing with\n  // paste or select and delete operation. We don't need to adjust the cursor position\n  // for those operations.\n  if (addedCount > 1 || removedCount > 1) {\n    return currentCursorPosition;\n  }\n\n  var placeholder = (0, _utilities.convertPatternToPlaceholder)(pattern);\n\n  //console.log(placeholder);\n  //console.log(placeholder[indexOfWhereChangeOccurred - 1]);\n\n  if (\n  // New character was added at the end of a pattern part. Find the nearest placeholder character\n  // to the right and return that the new cursor position\n  newCharacterIsPlaceholderCharacter !== true && placeholder[indexOfWhereChangeOccurred + 1] !== undefined && placeholder[indexOfWhereChangeOccurred + 1] !== _constants.placeholderCharacter) {\n    for (var i = indexOfWhereChangeOccurred + 2; i < placeholder.length; i++) {\n      if (placeholder[i] === _constants.placeholderCharacter) {\n        return i;\n      }\n    }\n\n    // New character possibly at the end of entire pattern. Just keep the cursor at its place.\n    return currentCursorPosition;\n  } else if (\n  // A character has actually been deleted and the previous spot in the pattern\n  // is not a placeholder. So, find the nearest placeholder character on the left and return that\n  // as the new cursor position\n  newCharacterIsPlaceholderCharacter === true && placeholder[indexOfWhereChangeOccurred - 1] !== undefined && placeholder[indexOfWhereChangeOccurred - 1] !== _constants.placeholderCharacter) {\n    for (var i = indexOfWhereChangeOccurred - 2; i > 0; i--) {\n      if (placeholder[i] === _constants.placeholderCharacter) {\n        return i + 1; // It should be right after the next placeholder character\n      }\n    }\n\n    return currentCursorPosition;\n  }\n\n  // Not sure yet why I need this condition here. There's a logical reason for it, but I will think\n  // about it later.\n  return !newCharacterIsPlaceholderCharacter ? indexOfWhereChangeOccurred + 1 : indexOfWhereChangeOccurred;\n}"},{"id":4,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","name":"./src/assignUserInputToPatternParts.js","index":6,"index2":5,"size":1290,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./assignUserInputToPatternParts.js","loc":"18:37-82"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assignUserInputToPatternParts;\n\nvar _utilities = require('./utilities.js');\n\nvar _processPart2 = require('./processPart.js');\n\nvar _processPart3 = _interopRequireDefault(_processPart2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction assignUserInputToPatternParts() {\n  var patternParts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n  var userInputParts = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n  var userInputIndex = 0;\n  var remainderFromLastProcessedUserInput = '';\n\n  return patternParts.map(function (patternPart) {\n    if (patternPart.length === 0) {\n      return patternPart;\n    }\n\n    var userInput = userInputParts && userInputParts[userInputIndex] ? remainderFromLastProcessedUserInput + userInputParts[userInputIndex] : remainderFromLastProcessedUserInput;\n\n    var _processPart = (0, _processPart3.default)(userInput, length);\n\n    var remainder = _processPart.remainder;\n    var results = _processPart.results;\n\n    remainderFromLastProcessedUserInput = remainder;\n    userInputIndex++;\n\n    patternPart.content = results;\n\n    return patternPart;\n  });\n}"},{"id":5,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","name":"./src/conformToPattern.js","index":1,"index2":6,"size":1044,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./conformToPattern.js","loc":"7:24-56"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = conformToPattern;\n\nvar _utilities = require('./utilities.js');\n\nvar _getPatternParts = require('./getPatternParts.js');\n\nvar _getPatternParts2 = _interopRequireDefault(_getPatternParts);\n\nvar _getUserInputParts = require('./getUserInputParts.js');\n\nvar _getUserInputParts2 = _interopRequireDefault(_getUserInputParts);\n\nvar _assignUserInputToPatternParts = require('./assignUserInputToPatternParts.js');\n\nvar _assignUserInputToPatternParts2 = _interopRequireDefault(_assignUserInputToPatternParts);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction conformToPattern(userInput, pattern) {\n  var patternParts = (0, _getPatternParts2.default)(pattern);\n  var userInputParts = (0, _getUserInputParts2.default)(userInput, pattern);\n  var mergedParts = (0, _assignUserInputToPatternParts2.default)(patternParts, userInputParts);\n\n  return (0, _utilities.constructConformedString)(mergedParts);\n}"},{"id":6,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getPatternParts.js","name":"./src/getPatternParts.js","index":4,"index2":2,"size":904,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./getPatternParts.js","loc":"10:23-54"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getPatternParts;\n\nvar _constants = require('./constants.js');\n\nvar _utilities = require('./utilities.js');\n\nfunction getPatternParts() {\n  var pattern = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  var placeholder = (0, _utilities.convertPatternToPlaceholder)(pattern);\n  var patternParts = [];\n\n  var lengthOfPart = 0;\n  placeholder.split('').forEach(function (character) {\n    if (character === _constants.placeholderCharacter) {\n      lengthOfPart++;\n    } else {\n      patternParts.push({\n        length: lengthOfPart,\n        delimiter: character,\n        content: ''\n      });\n\n      lengthOfPart = 0;\n    }\n  });\n\n  if (lengthOfPart > 0) {\n    patternParts.push({\n      length: lengthOfPart,\n      delimiter: '',\n      content: ''\n    });\n  }\n\n  return patternParts;\n}"},{"id":7,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getUserInputParts.js","name":"./src/getUserInputParts.js","index":5,"index2":3,"size":964,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./getUserInputParts.js","loc":"14:25-58"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getUserInputParts;\n\nvar _utilities = require('./utilities.js');\n\nfunction getUserInputParts() {\n  var userInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var pattern = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n  var userInputParts = [];\n  var delimiters = (0, _utilities.getDelimiters)(pattern);\n\n  var lastEncounteredUserInputChunk = '';\n  userInput.split('').forEach(function (character) {\n    if (delimiters.indexOf(character) === -1) {\n      lastEncounteredUserInputChunk += character;\n    } else if (lastEncounteredUserInputChunk.length > 0) {\n      userInputParts.push(lastEncounteredUserInputChunk);\n      lastEncounteredUserInputChunk = '';\n    }\n  });\n\n  if (lastEncounteredUserInputChunk.length > 0) {\n    userInputParts.push(lastEncounteredUserInputChunk);\n  }\n\n  return userInputParts;\n}"},{"id":8,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/processPart.js","name":"./src/processPart.js","index":7,"index2":4,"size":719,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":4,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","module":"./src/assignUserInputToPatternParts.js","moduleName":"./src/assignUserInputToPatternParts.js","type":"cjs require","userRequest":"./processPart.js","loc":"10:20-47"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processPart;\n\nvar _utilities = require('./utilities.js');\n\nvar _constants = require('./constants.js');\n\nfunction processPart() {\n  var userInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var acceptedLength = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n  var head = userInput.substr(0, acceptedLength);\n  var tail = userInput.substr(acceptedLength, userInput.length);\n  var sizeDifference = acceptedLength - head.length;\n\n  return {\n    results: head + (0, _utilities.printPadding)(_constants.placeholderCharacter, sizeDifference),\n    remainder: tail\n  };\n}"},{"id":9,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/diff/diff.js","name":"./~/diff/diff.js","index":9,"index2":7,"size":20791,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","module":"./src/adjustCursorPosition.js","moduleName":"./src/adjustCursorPosition.js","type":"cjs require","userRequest":"diff","loc":"8:12-27"}],"source":"/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n(function(global, undefined) {\n  var objectPrototypeToString = Object.prototype.toString;\n\n  /*istanbul ignore next*/\n  function map(arr, mapper, that) {\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, mapper, that);\n    }\n\n    var other = new Array(arr.length);\n\n    for (var i = 0, n = arr.length; i < n; i++) {\n      other[i] = mapper.call(that, arr[i], i, arr);\n    }\n    return other;\n  }\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n\n    return n;\n  }\n\n  // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed.\n  function canonicalize(obj, stack, replacementStack) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else if (typeof obj === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n      var sortedKeys = [],\n          key;\n      for (key in obj) {\n        sortedKeys.push(key);\n      }\n      sortedKeys.sort();\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        key = sortedKeys[i];\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n  }\n\n  function buildValues(components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = map(value, function(value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n\n          component.value = value.join('');\n        } else {\n          component.value = newString.slice(newPos, newPos + component.count).join('');\n        }\n        newPos += component.count;\n\n        // Common case\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\n        oldPos += component.count;\n\n        // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    }\n\n    return components;\n  }\n\n  function Diff(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  }\n  Diff.prototype = {\n    diff: function(oldString, newString, callback) {\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function() { callback(undefined, value); }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      }\n\n      // Handle the identity case (this is due to unrolling editLength == 0\n      if (newString === oldString) {\n        return done([{ value: newString }]);\n      }\n      if (!newString) {\n        return done([{ value: oldString, removed: true }]);\n      }\n      if (!oldString) {\n        return done([{ value: newString, added: true }]);\n      }\n\n      newString = this.tokenize(newString);\n      oldString = this.tokenize(oldString);\n\n      var newLen = newString.length, oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{ newPos: -1, components: [] }];\n\n      // Seed editLength = 0, i.e. the content starts with the same values\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{value: newString.join('')}]);\n      }\n\n      // Main worker method. checks all permutations of a given edit length for acceptance.\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath;\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          }\n\n          // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath;   // No need to clone, we've pulled it from the list\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n          // If we have hit the end of both strings, then we are done\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      }\n\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n      if (callback) {\n        (function exec() {\n          setTimeout(function() {\n            // This should not happen, but we want to be safe.\n            /*istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        }());\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    pushComponent: function(components, added, removed) {\n      var last = components[components.length - 1];\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n      } else {\n        components.push({count: 1, added: added, removed: removed });\n      }\n    },\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n\n          commonCount = 0;\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({count: commonCount});\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n\n    equals: function(left, right) {\n      var reWhitespace = /\\S/;\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n    },\n    tokenize: function(value) {\n      return value.split('');\n    }\n  };\n\n  var CharDiff = new Diff();\n\n  var WordDiff = new Diff(true);\n  var WordWithSpaceDiff = new Diff();\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n\n  var CssDiff = new Diff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n\n  var LineDiff = new Diff();\n\n  var TrimmedLineDiff = new Diff();\n  TrimmedLineDiff.ignoreTrim = true;\n\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\n    var retLines = [],\n        lines = value.split(/^/m);\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i],\n          lastLine = lines[i - 1],\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\n\n      // Merge lines that may contain windows new lines\n      if (line === '\\n' && lastLineLastChar === '\\r') {\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\r\\n';\n      } else {\n        if (this.ignoreTrim) {\n          line = line.trim();\n          // add a newline unless this is the last line.\n          if (i < lines.length - 1) {\n            line += '\\n';\n          }\n        }\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  var PatchDiff = new Diff();\n  PatchDiff.tokenize = function(value) {\n    var ret = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    }\n\n    // Merge the content and line separators into single tokens\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2) {\n        ret[ret.length - 1] += line;\n      } else {\n        ret.push(line);\n      }\n    }\n    return ret;\n  };\n\n  var SentenceDiff = new Diff();\n  SentenceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\S.+?[.!?])(?=\\s+|$)/));\n  };\n\n  var JsonDiff = new Diff();\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n  JsonDiff.useLongestToken = true;\n  JsonDiff.tokenize = LineDiff.tokenize;\n  JsonDiff.equals = function(left, right) {\n    return LineDiff.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  var JsDiff = {\n    Diff: Diff,\n\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\n\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\n\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\n    diffJson: function(oldObj, newObj, callback) {\n      return JsonDiff.diff(\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\n        callback\n      );\n    },\n\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      if (oldFileName == newFileName) {\n        ret.push('Index: ' + oldFileName);\n      }\n      ret.push('===================================================================');\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n      var diff = PatchDiff.diff(oldStr, newStr);\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n      // Formats a given set of lines for printing as context lines in a patch\n      function contextLines(lines) {\n        return map(lines, function(entry) { return ' ' + entry; });\n      }\n\n      // Outputs the no newline at end of file warning if needed\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length - 2],\n            isLast = i === diff.length - 2,\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!(/\\n$/.test(current.value)) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          // If we have previous context, start with that\n          if (!oldRangeStart) {\n            var prev = diff[i - 1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n\n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n\n          // Output our changes\n          curRange.push.apply(curRange, map(lines, function(entry) {\n            return (current.added ? '+' : '-') + entry;\n          }));\n          eofNL(curRange, i, current);\n\n          // Track the updated file position\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          // Identical context lines. Track line changes\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length - 2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\n                  + ' @@');\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;\n              newRangeStart = 0;\n              curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\n    },\n\n    applyPatch: function(oldStr, uniDiff) {\n      var diffstr = uniDiff.split('\\n'),\n          hunks = [],\n          i = 0,\n          remEOFNL = false,\n          addEOFNL = false;\n\n      // Skip to the first change hunk\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\n        i++;\n      }\n\n      // Parse the unified diff\n      for (; i < diffstr.length; i++) {\n        if (diffstr[i][0] === '@') {\n          var chnukHeader = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n          hunks.unshift({\n            start: chnukHeader[3],\n            oldlength: +chnukHeader[2],\n            removed: [],\n            newlength: chnukHeader[4],\n            added: []\n          });\n        } else if (diffstr[i][0] === '+') {\n          hunks[0].added.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '-') {\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === ' ') {\n          hunks[0].added.push(diffstr[i].substr(1));\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '\\\\') {\n          if (diffstr[i - 1][0] === '+') {\n            remEOFNL = true;\n          } else if (diffstr[i - 1][0] === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n\n      // Apply the diff to the input\n      var lines = oldStr.split('\\n');\n      for (i = hunks.length - 1; i >= 0; i--) {\n        var hunk = hunks[i];\n        // Sanity check the input string. Bail if we don't match.\n        for (var j = 0; j < hunk.oldlength; j++) {\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\n            return false;\n          }\n        }\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\n      }\n\n      // Handle EOFNL insertion/removal\n      if (remEOFNL) {\n        while (!lines[lines.length - 1]) {\n          lines.pop();\n        }\n      } else if (addEOFNL) {\n        lines.push('');\n      }\n      return lines.join('\\n');\n    },\n\n    convertChangesToXML: function(changes) {\n      var ret = [];\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    },\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    convertChangesToDMP: function(changes) {\n      var ret = [],\n          change,\n          operation;\n      for (var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        if (change.added) {\n          operation = 1;\n        } else if (change.removed) {\n          operation = -1;\n        } else {\n          operation = 0;\n        }\n\n        ret.push([operation, change.value]);\n      }\n      return ret;\n    },\n\n    canonicalize: canonicalize\n  };\n\n  /*istanbul ignore next */\n  /*global module */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = JsDiff;\n  } else if (typeof define === 'function' && define.amd) {\n    /*global define */\n    define([], function() { return JsDiff; });\n  } else if (typeof global.JsDiff === 'undefined') {\n    global.JsDiff = JsDiff;\n  }\n}(this));\n"}],"filteredModules":0,"origins":[{"moduleId":0,"module":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","moduleName":"./src/index.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":0,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","name":"./src/index.js","index":0,"index2":9,"size":646,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _conformToPattern = require(\"./conformToPattern.js\");\n\nObject.defineProperty(exports, \"conformToPattern\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_conformToPattern).default;\n  }\n});\n\nvar _adjustCursorPosition = require(\"./adjustCursorPosition.js\");\n\nObject.defineProperty(exports, \"adjustCursorPosition\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_adjustCursorPosition).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }"},{"id":1,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/utilities.js","name":"./src/utilities.js","index":2,"index2":1,"size":2713,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","module":"./src/adjustCursorPosition.js","moduleName":"./src/adjustCursorPosition.js","type":"cjs require","userRequest":"./utilities.js","loc":"12:17-42"},{"moduleId":4,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","module":"./src/assignUserInputToPatternParts.js","moduleName":"./src/assignUserInputToPatternParts.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":6,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getPatternParts.js","module":"./src/getPatternParts.js","moduleName":"./src/getPatternParts.js","type":"cjs require","userRequest":"./utilities.js","loc":"10:17-42"},{"moduleId":7,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getUserInputParts.js","module":"./src/getUserInputParts.js","moduleName":"./src/getUserInputParts.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"},{"moduleId":8,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/processPart.js","module":"./src/processPart.js","moduleName":"./src/processPart.js","type":"cjs require","userRequest":"./utilities.js","loc":"8:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertPatternToPlaceholder = convertPatternToPlaceholder;\nexports.removeCharactersStartingAtIndex = removeCharactersStartingAtIndex;\nexports.getOperationType = getOperationType;\nexports.getDelimiters = getDelimiters;\nexports.printPadding = printPadding;\nexports.constructConformedString = constructConformedString;\n\nvar _constants = require('./constants.js');\n\nfunction convertPatternToPlaceholder() {\n  var pattern = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return pattern.replace(/1/g, _constants.placeholderCharacter);\n}\n\nfunction removeCharactersStartingAtIndex() {\n  var string = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n  var numberOfCharacters = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n  return string.substring(0, index) + string.substring(index + numberOfCharacters);\n}\n\nfunction getOperationType() {\n  var currentValue = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var previousValue = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n  return currentValue.length === previousValue.length ? _constants.operationTypes.replacement : currentValue.length > previousValue.length ? _constants.operationTypes.addition : currentValue.length < previousValue.length ? _constants.operationTypes.deletion : null;\n}\n\nfunction getDelimiters() {\n  var pattern = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  return pattern.split('').reduce(function (accumulator, character) {\n    if (_constants.maskingCharacters.indexOf(character) === -1 && accumulator.indexOf(character) === -1) {\n      accumulator.push(character);\n    }\n\n    return accumulator;\n  }, []);\n}\n\nfunction printPadding(paddingCharacter, length) {\n  return Array.from({ length: length }, function () {\n    return paddingCharacter;\n  }).join('');\n}\n\nfunction constructConformedString(patternPartsWithContent) {\n  return patternPartsWithContent.reduce(function (accumulator, editableAreaWithContent) {\n    var _editableAreaWithCont = editableAreaWithContent.content;\n    var content = _editableAreaWithCont === undefined ? '' : _editableAreaWithCont;\n    var length = editableAreaWithContent.length;\n    var delimiter = editableAreaWithContent.delimiter;\n\n    var contentAndLengthDelta = length - content.length;\n    var padding = printPadding(_constants.placeholderCharacter, contentAndLengthDelta);\n\n    accumulator += content + padding + (delimiter || '');\n\n    return accumulator;\n  }, '');\n}"},{"id":2,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/constants.js","name":"./src/constants.js","index":3,"index2":0,"size":341,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":1,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/utilities.js","module":"./src/utilities.js","moduleName":"./src/utilities.js","type":"cjs require","userRequest":"./constants.js","loc":"13:17-42"},{"moduleId":3,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","module":"./src/adjustCursorPosition.js","moduleName":"./src/adjustCursorPosition.js","type":"cjs require","userRequest":"./constants.js","loc":"14:17-42"},{"moduleId":6,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getPatternParts.js","module":"./src/getPatternParts.js","moduleName":"./src/getPatternParts.js","type":"cjs require","userRequest":"./constants.js","loc":"8:17-42"},{"moduleId":8,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/processPart.js","module":"./src/processPart.js","moduleName":"./src/processPart.js","type":"cjs require","userRequest":"./constants.js","loc":"10:17-42"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar operationTypes = exports.operationTypes = {\n  replacement: 'replacement',\n  addition: 'addition',\n  deletion: 'deletion'\n};\n\nvar maskingCharacters = exports.maskingCharacters = ['1', 'A', '#'];\n\nvar placeholderCharacter = exports.placeholderCharacter = '_';"},{"id":3,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","name":"./src/adjustCursorPosition.js","index":8,"index2":8,"size":4292,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./adjustCursorPosition.js","loc":"16:28-64"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = adjustCursorPosition;\n\nvar _diff = require('diff');\n\nvar _diff2 = _interopRequireDefault(_diff);\n\nvar _utilities = require('./utilities.js');\n\nvar _constants = require('./constants.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction adjustCursorPosition() {\n  var previousUserInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var newUserInput = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n  var currentCursorPosition = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n  var pattern = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];\n\n  // Nothing changed. Keep cursor at where it currently is.\n  if (previousUserInput === newUserInput) {\n    return currentCursorPosition;\n  }\n\n  var diffResults = _diff2.default.diffChars(previousUserInput, newUserInput);\n\n  var addedCount = 0;\n  var removedCount = 0;\n  var charactersBeforeChangeOccurred = '';\n  var indexOfWhereChangeOccurred = -1;\n  var newCharacterIsPlaceholderCharacter = null;\n\n  diffResults.forEach(function (result) {\n    charactersBeforeChangeOccurred += result.value;\n\n    if (result.added === true) {\n      addedCount += result.count;\n      newCharacterIsPlaceholderCharacter = result.value === _constants.placeholderCharacter;\n      indexOfWhereChangeOccurred = indexOfWhereChangeOccurred === -1 ? charactersBeforeChangeOccurred.length - 1 : indexOfWhereChangeOccurred;\n    }\n\n    if (result.removed === true) {\n      removedCount += result.count;\n      indexOfWhereChangeOccurred = indexOfWhereChangeOccurred === -1 ? charactersBeforeChangeOccurred.length - 1 : indexOfWhereChangeOccurred;\n    }\n  });\n\n  //console.log(diffResults);\n  //console.log(indexOfWhereChangeOccurred);\n  //console.log(newCharacterIsPlaceholderCharacter);\n\n  // The cursor position and the change are too far apart, which means some ambiguous change\n  // happened. I.e (333) ___-____ to (333) 3__-____\n  // In that case, just return the currentCursorPosition\n  if (indexOfWhereChangeOccurred - currentCursorPosition > 1) {\n    return currentCursorPosition;\n  }\n\n  // There are more than one change in the diffResults, which means we're dealing with\n  // paste or select and delete operation. We don't need to adjust the cursor position\n  // for those operations.\n  if (addedCount > 1 || removedCount > 1) {\n    return currentCursorPosition;\n  }\n\n  var placeholder = (0, _utilities.convertPatternToPlaceholder)(pattern);\n\n  //console.log(placeholder);\n  //console.log(placeholder[indexOfWhereChangeOccurred - 1]);\n\n  if (\n  // New character was added at the end of a pattern part. Find the nearest placeholder character\n  // to the right and return that the new cursor position\n  newCharacterIsPlaceholderCharacter !== true && placeholder[indexOfWhereChangeOccurred + 1] !== undefined && placeholder[indexOfWhereChangeOccurred + 1] !== _constants.placeholderCharacter) {\n    for (var i = indexOfWhereChangeOccurred + 2; i < placeholder.length; i++) {\n      if (placeholder[i] === _constants.placeholderCharacter) {\n        return i;\n      }\n    }\n\n    // New character possibly at the end of entire pattern. Just keep the cursor at its place.\n    return currentCursorPosition;\n  } else if (\n  // A character has actually been deleted and the previous spot in the pattern\n  // is not a placeholder. So, find the nearest placeholder character on the left and return that\n  // as the new cursor position\n  newCharacterIsPlaceholderCharacter === true && placeholder[indexOfWhereChangeOccurred - 1] !== undefined && placeholder[indexOfWhereChangeOccurred - 1] !== _constants.placeholderCharacter) {\n    for (var i = indexOfWhereChangeOccurred - 2; i > 0; i--) {\n      if (placeholder[i] === _constants.placeholderCharacter) {\n        return i + 1; // It should be right after the next placeholder character\n      }\n    }\n\n    return currentCursorPosition;\n  }\n\n  // Not sure yet why I need this condition here. There's a logical reason for it, but I will think\n  // about it later.\n  return !newCharacterIsPlaceholderCharacter ? indexOfWhereChangeOccurred + 1 : indexOfWhereChangeOccurred;\n}"},{"id":4,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","name":"./src/assignUserInputToPatternParts.js","index":6,"index2":5,"size":1290,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./assignUserInputToPatternParts.js","loc":"18:37-82"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assignUserInputToPatternParts;\n\nvar _utilities = require('./utilities.js');\n\nvar _processPart2 = require('./processPart.js');\n\nvar _processPart3 = _interopRequireDefault(_processPart2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction assignUserInputToPatternParts() {\n  var patternParts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n  var userInputParts = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n  var userInputIndex = 0;\n  var remainderFromLastProcessedUserInput = '';\n\n  return patternParts.map(function (patternPart) {\n    if (patternPart.length === 0) {\n      return patternPart;\n    }\n\n    var userInput = userInputParts && userInputParts[userInputIndex] ? remainderFromLastProcessedUserInput + userInputParts[userInputIndex] : remainderFromLastProcessedUserInput;\n\n    var _processPart = (0, _processPart3.default)(userInput, length);\n\n    var remainder = _processPart.remainder;\n    var results = _processPart.results;\n\n    remainderFromLastProcessedUserInput = remainder;\n    userInputIndex++;\n\n    patternPart.content = results;\n\n    return patternPart;\n  });\n}"},{"id":5,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","name":"./src/conformToPattern.js","index":1,"index2":6,"size":1044,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/index.js","module":"./src/index.js","moduleName":"./src/index.js","type":"cjs require","userRequest":"./conformToPattern.js","loc":"7:24-56"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = conformToPattern;\n\nvar _utilities = require('./utilities.js');\n\nvar _getPatternParts = require('./getPatternParts.js');\n\nvar _getPatternParts2 = _interopRequireDefault(_getPatternParts);\n\nvar _getUserInputParts = require('./getUserInputParts.js');\n\nvar _getUserInputParts2 = _interopRequireDefault(_getUserInputParts);\n\nvar _assignUserInputToPatternParts = require('./assignUserInputToPatternParts.js');\n\nvar _assignUserInputToPatternParts2 = _interopRequireDefault(_assignUserInputToPatternParts);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction conformToPattern(userInput, pattern) {\n  var patternParts = (0, _getPatternParts2.default)(pattern);\n  var userInputParts = (0, _getUserInputParts2.default)(userInput, pattern);\n  var mergedParts = (0, _assignUserInputToPatternParts2.default)(patternParts, userInputParts);\n\n  return (0, _utilities.constructConformedString)(mergedParts);\n}"},{"id":6,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getPatternParts.js","name":"./src/getPatternParts.js","index":4,"index2":2,"size":904,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./getPatternParts.js","loc":"10:23-54"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getPatternParts;\n\nvar _constants = require('./constants.js');\n\nvar _utilities = require('./utilities.js');\n\nfunction getPatternParts() {\n  var pattern = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  var placeholder = (0, _utilities.convertPatternToPlaceholder)(pattern);\n  var patternParts = [];\n\n  var lengthOfPart = 0;\n  placeholder.split('').forEach(function (character) {\n    if (character === _constants.placeholderCharacter) {\n      lengthOfPart++;\n    } else {\n      patternParts.push({\n        length: lengthOfPart,\n        delimiter: character,\n        content: ''\n      });\n\n      lengthOfPart = 0;\n    }\n  });\n\n  if (lengthOfPart > 0) {\n    patternParts.push({\n      length: lengthOfPart,\n      delimiter: '',\n      content: ''\n    });\n  }\n\n  return patternParts;\n}"},{"id":7,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/getUserInputParts.js","name":"./src/getUserInputParts.js","index":5,"index2":3,"size":964,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":5,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/conformToPattern.js","module":"./src/conformToPattern.js","moduleName":"./src/conformToPattern.js","type":"cjs require","userRequest":"./getUserInputParts.js","loc":"14:25-58"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getUserInputParts;\n\nvar _utilities = require('./utilities.js');\n\nfunction getUserInputParts() {\n  var userInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var pattern = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n  var userInputParts = [];\n  var delimiters = (0, _utilities.getDelimiters)(pattern);\n\n  var lastEncounteredUserInputChunk = '';\n  userInput.split('').forEach(function (character) {\n    if (delimiters.indexOf(character) === -1) {\n      lastEncounteredUserInputChunk += character;\n    } else if (lastEncounteredUserInputChunk.length > 0) {\n      userInputParts.push(lastEncounteredUserInputChunk);\n      lastEncounteredUserInputChunk = '';\n    }\n  });\n\n  if (lastEncounteredUserInputChunk.length > 0) {\n    userInputParts.push(lastEncounteredUserInputChunk);\n  }\n\n  return userInputParts;\n}"},{"id":8,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/processPart.js","name":"./src/processPart.js","index":7,"index2":4,"size":719,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":4,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/assignUserInputToPatternParts.js","module":"./src/assignUserInputToPatternParts.js","moduleName":"./src/assignUserInputToPatternParts.js","type":"cjs require","userRequest":"./processPart.js","loc":"10:20-47"}],"source":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processPart;\n\nvar _utilities = require('./utilities.js');\n\nvar _constants = require('./constants.js');\n\nfunction processPart() {\n  var userInput = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n  var acceptedLength = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n  var head = userInput.substr(0, acceptedLength);\n  var tail = userInput.substr(acceptedLength, userInput.length);\n  var sizeDifference = acceptedLength - head.length;\n\n  return {\n    results: head + (0, _utilities.printPadding)(_constants.placeholderCharacter, sizeDifference),\n    remainder: tail\n  };\n}"},{"id":9,"identifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/diff/diff.js","name":"./~/diff/diff.js","index":9,"index2":7,"size":20791,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":3,"moduleIdentifier":"/Users/mk/Code/github/msafi/string-pattern/node_modules/babel-loader/index.js!/Users/mk/Code/github/msafi/string-pattern/src/adjustCursorPosition.js","module":"./src/adjustCursorPosition.js","moduleName":"./src/adjustCursorPosition.js","type":"cjs require","userRequest":"diff","loc":"8:12-27"}],"source":"/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n(function(global, undefined) {\n  var objectPrototypeToString = Object.prototype.toString;\n\n  /*istanbul ignore next*/\n  function map(arr, mapper, that) {\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, mapper, that);\n    }\n\n    var other = new Array(arr.length);\n\n    for (var i = 0, n = arr.length; i < n; i++) {\n      other[i] = mapper.call(that, arr[i], i, arr);\n    }\n    return other;\n  }\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n\n    return n;\n  }\n\n  // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed.\n  function canonicalize(obj, stack, replacementStack) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else if (typeof obj === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n      var sortedKeys = [],\n          key;\n      for (key in obj) {\n        sortedKeys.push(key);\n      }\n      sortedKeys.sort();\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        key = sortedKeys[i];\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n  }\n\n  function buildValues(components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = map(value, function(value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n\n          component.value = value.join('');\n        } else {\n          component.value = newString.slice(newPos, newPos + component.count).join('');\n        }\n        newPos += component.count;\n\n        // Common case\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\n        oldPos += component.count;\n\n        // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    }\n\n    return components;\n  }\n\n  function Diff(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  }\n  Diff.prototype = {\n    diff: function(oldString, newString, callback) {\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function() { callback(undefined, value); }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      }\n\n      // Handle the identity case (this is due to unrolling editLength == 0\n      if (newString === oldString) {\n        return done([{ value: newString }]);\n      }\n      if (!newString) {\n        return done([{ value: oldString, removed: true }]);\n      }\n      if (!oldString) {\n        return done([{ value: newString, added: true }]);\n      }\n\n      newString = this.tokenize(newString);\n      oldString = this.tokenize(oldString);\n\n      var newLen = newString.length, oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{ newPos: -1, components: [] }];\n\n      // Seed editLength = 0, i.e. the content starts with the same values\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{value: newString.join('')}]);\n      }\n\n      // Main worker method. checks all permutations of a given edit length for acceptance.\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath;\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          }\n\n          // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath;   // No need to clone, we've pulled it from the list\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n          // If we have hit the end of both strings, then we are done\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      }\n\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n      if (callback) {\n        (function exec() {\n          setTimeout(function() {\n            // This should not happen, but we want to be safe.\n            /*istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        }());\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    pushComponent: function(components, added, removed) {\n      var last = components[components.length - 1];\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n      } else {\n        components.push({count: 1, added: added, removed: removed });\n      }\n    },\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n\n          commonCount = 0;\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({count: commonCount});\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n\n    equals: function(left, right) {\n      var reWhitespace = /\\S/;\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n    },\n    tokenize: function(value) {\n      return value.split('');\n    }\n  };\n\n  var CharDiff = new Diff();\n\n  var WordDiff = new Diff(true);\n  var WordWithSpaceDiff = new Diff();\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n\n  var CssDiff = new Diff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n\n  var LineDiff = new Diff();\n\n  var TrimmedLineDiff = new Diff();\n  TrimmedLineDiff.ignoreTrim = true;\n\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\n    var retLines = [],\n        lines = value.split(/^/m);\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i],\n          lastLine = lines[i - 1],\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\n\n      // Merge lines that may contain windows new lines\n      if (line === '\\n' && lastLineLastChar === '\\r') {\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\r\\n';\n      } else {\n        if (this.ignoreTrim) {\n          line = line.trim();\n          // add a newline unless this is the last line.\n          if (i < lines.length - 1) {\n            line += '\\n';\n          }\n        }\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  var PatchDiff = new Diff();\n  PatchDiff.tokenize = function(value) {\n    var ret = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    }\n\n    // Merge the content and line separators into single tokens\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2) {\n        ret[ret.length - 1] += line;\n      } else {\n        ret.push(line);\n      }\n    }\n    return ret;\n  };\n\n  var SentenceDiff = new Diff();\n  SentenceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\S.+?[.!?])(?=\\s+|$)/));\n  };\n\n  var JsonDiff = new Diff();\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n  JsonDiff.useLongestToken = true;\n  JsonDiff.tokenize = LineDiff.tokenize;\n  JsonDiff.equals = function(left, right) {\n    return LineDiff.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  var JsDiff = {\n    Diff: Diff,\n\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\n\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\n\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\n    diffJson: function(oldObj, newObj, callback) {\n      return JsonDiff.diff(\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\n        callback\n      );\n    },\n\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      if (oldFileName == newFileName) {\n        ret.push('Index: ' + oldFileName);\n      }\n      ret.push('===================================================================');\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n      var diff = PatchDiff.diff(oldStr, newStr);\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n      // Formats a given set of lines for printing as context lines in a patch\n      function contextLines(lines) {\n        return map(lines, function(entry) { return ' ' + entry; });\n      }\n\n      // Outputs the no newline at end of file warning if needed\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length - 2],\n            isLast = i === diff.length - 2,\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!(/\\n$/.test(current.value)) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          // If we have previous context, start with that\n          if (!oldRangeStart) {\n            var prev = diff[i - 1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n\n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n\n          // Output our changes\n          curRange.push.apply(curRange, map(lines, function(entry) {\n            return (current.added ? '+' : '-') + entry;\n          }));\n          eofNL(curRange, i, current);\n\n          // Track the updated file position\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          // Identical context lines. Track line changes\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length - 2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\n                  + ' @@');\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;\n              newRangeStart = 0;\n              curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\n    },\n\n    applyPatch: function(oldStr, uniDiff) {\n      var diffstr = uniDiff.split('\\n'),\n          hunks = [],\n          i = 0,\n          remEOFNL = false,\n          addEOFNL = false;\n\n      // Skip to the first change hunk\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\n        i++;\n      }\n\n      // Parse the unified diff\n      for (; i < diffstr.length; i++) {\n        if (diffstr[i][0] === '@') {\n          var chnukHeader = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n          hunks.unshift({\n            start: chnukHeader[3],\n            oldlength: +chnukHeader[2],\n            removed: [],\n            newlength: chnukHeader[4],\n            added: []\n          });\n        } else if (diffstr[i][0] === '+') {\n          hunks[0].added.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '-') {\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === ' ') {\n          hunks[0].added.push(diffstr[i].substr(1));\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '\\\\') {\n          if (diffstr[i - 1][0] === '+') {\n            remEOFNL = true;\n          } else if (diffstr[i - 1][0] === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n\n      // Apply the diff to the input\n      var lines = oldStr.split('\\n');\n      for (i = hunks.length - 1; i >= 0; i--) {\n        var hunk = hunks[i];\n        // Sanity check the input string. Bail if we don't match.\n        for (var j = 0; j < hunk.oldlength; j++) {\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\n            return false;\n          }\n        }\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\n      }\n\n      // Handle EOFNL insertion/removal\n      if (remEOFNL) {\n        while (!lines[lines.length - 1]) {\n          lines.pop();\n        }\n      } else if (addEOFNL) {\n        lines.push('');\n      }\n      return lines.join('\\n');\n    },\n\n    convertChangesToXML: function(changes) {\n      var ret = [];\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    },\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    convertChangesToDMP: function(changes) {\n      var ret = [],\n          change,\n          operation;\n      for (var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        if (change.added) {\n          operation = 1;\n        } else if (change.removed) {\n          operation = -1;\n        } else {\n          operation = 0;\n        }\n\n        ret.push([operation, change.value]);\n      }\n      return ret;\n    },\n\n    canonicalize: canonicalize\n  };\n\n  /*istanbul ignore next */\n  /*global module */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = JsDiff;\n  } else if (typeof define === 'function' && define.amd) {\n    /*global define */\n    define([], function() { return JsDiff; });\n  } else if (typeof global.JsDiff === 'undefined') {\n    global.JsDiff = JsDiff;\n  }\n}(this));\n"}],"filteredModules":0,"children":[]}